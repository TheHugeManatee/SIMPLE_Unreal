// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_
#define FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_

#include "flatbuffers/flatbuffers.h"

namespace simple_msgs {

struct uint8_type;

struct int16_type;

struct float_type;

struct double_type;

struct ImageFbs;

enum data {
  data_NONE = 0,
  data_uint8_type = 1,
  data_int16_type = 2,
  data_float_type = 3,
  data_double_type = 4,
  data_MIN = data_NONE,
  data_MAX = data_double_type
};

inline const data (&EnumValuesdata())[5] {
  static const data values[] = {
    data_NONE,
    data_uint8_type,
    data_int16_type,
    data_float_type,
    data_double_type
  };
  return values;
}

inline const char * const *EnumNamesdata() {
  static const char * const names[] = {
    "NONE",
    "uint8_type",
    "int16_type",
    "float_type",
    "double_type",
    nullptr
  };
  return names;
}

inline const char *EnumNamedata(data e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesdata()[index];
}

template<typename T> struct dataTraits {
  static const data enum_value = data_NONE;
};

template<> struct dataTraits<uint8_type> {
  static const data enum_value = data_uint8_type;
};

template<> struct dataTraits<int16_type> {
  static const data enum_value = data_int16_type;
};

template<> struct dataTraits<float_type> {
  static const data enum_value = data_float_type;
};

template<> struct dataTraits<double_type> {
  static const data enum_value = data_double_type;
};

bool Verifydata(flatbuffers::Verifier &verifier, const void *obj, data type);
bool VerifydataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct uint8_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RAW = 4
  };
  const flatbuffers::Vector<uint8_t> *raw() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_RAW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RAW) &&
           verifier.Verify(raw()) &&
           verifier.EndTable();
  }
};

struct uint8_typeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw) {
    fbb_.AddOffset(uint8_type::VT_RAW, raw);
  }
  explicit uint8_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  uint8_typeBuilder &operator=(const uint8_typeBuilder &);
  flatbuffers::Offset<uint8_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<uint8_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<uint8_type> Createuint8_type(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> raw = 0) {
  uint8_typeBuilder builder_(_fbb);
  builder_.add_raw(raw);
  return builder_.Finish();
}

inline flatbuffers::Offset<uint8_type> Createuint8_typeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *raw = nullptr) {
  return simple_msgs::Createuint8_type(
      _fbb,
      raw ? _fbb.CreateVector<uint8_t>(*raw) : 0);
}

struct int16_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RAW = 4
  };
  const flatbuffers::Vector<int16_t> *raw() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_RAW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RAW) &&
           verifier.Verify(raw()) &&
           verifier.EndTable();
  }
};

struct int16_typeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw(flatbuffers::Offset<flatbuffers::Vector<int16_t>> raw) {
    fbb_.AddOffset(int16_type::VT_RAW, raw);
  }
  explicit int16_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  int16_typeBuilder &operator=(const int16_typeBuilder &);
  flatbuffers::Offset<int16_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<int16_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<int16_type> Createint16_type(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> raw = 0) {
  int16_typeBuilder builder_(_fbb);
  builder_.add_raw(raw);
  return builder_.Finish();
}

inline flatbuffers::Offset<int16_type> Createint16_typeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *raw = nullptr) {
  return simple_msgs::Createint16_type(
      _fbb,
      raw ? _fbb.CreateVector<int16_t>(*raw) : 0);
}

struct float_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RAW = 4
  };
  const flatbuffers::Vector<float> *raw() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RAW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RAW) &&
           verifier.Verify(raw()) &&
           verifier.EndTable();
  }
};

struct float_typeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw(flatbuffers::Offset<flatbuffers::Vector<float>> raw) {
    fbb_.AddOffset(float_type::VT_RAW, raw);
  }
  explicit float_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  float_typeBuilder &operator=(const float_typeBuilder &);
  flatbuffers::Offset<float_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<float_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<float_type> Createfloat_type(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> raw = 0) {
  float_typeBuilder builder_(_fbb);
  builder_.add_raw(raw);
  return builder_.Finish();
}

inline flatbuffers::Offset<float_type> Createfloat_typeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *raw = nullptr) {
  return simple_msgs::Createfloat_type(
      _fbb,
      raw ? _fbb.CreateVector<float>(*raw) : 0);
}

struct double_type FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RAW = 4
  };
  const flatbuffers::Vector<double> *raw() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_RAW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RAW) &&
           verifier.Verify(raw()) &&
           verifier.EndTable();
  }
};

struct double_typeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_raw(flatbuffers::Offset<flatbuffers::Vector<double>> raw) {
    fbb_.AddOffset(double_type::VT_RAW, raw);
  }
  explicit double_typeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  double_typeBuilder &operator=(const double_typeBuilder &);
  flatbuffers::Offset<double_type> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<double_type>(end);
    return o;
  }
};

inline flatbuffers::Offset<double_type> Createdouble_type(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> raw = 0) {
  double_typeBuilder builder_(_fbb);
  builder_.add_raw(raw);
  return builder_.Finish();
}

inline flatbuffers::Offset<double_type> Createdouble_typeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *raw = nullptr) {
  return simple_msgs::Createdouble_type(
      _fbb,
      raw ? _fbb.CreateVector<double>(*raw) : 0);
}

struct ImageFbs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_ORIGIN = 6,
    VT_ENCODING = 8,
    VT_SPACING_X = 10,
    VT_SPACING_Y = 12,
    VT_SPACING_Z = 14,
    VT_WIDTH = 16,
    VT_HEIGHT = 18,
    VT_DEPTH = 20,
    VT_IMAGE_TYPE = 22,
    VT_IMAGE = 24,
    VT_IMAGE_SIZE = 26,
    VT_NUM_CHANNELS = 28
  };
  const flatbuffers::Vector<uint8_t> *header() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HEADER);
  }
  const flatbuffers::Vector<uint8_t> *origin() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ORIGIN);
  }
  const flatbuffers::String *encoding() const {
    return GetPointer<const flatbuffers::String *>(VT_ENCODING);
  }
  double spacing_x() const {
    return GetField<double>(VT_SPACING_X, 0.0);
  }
  double spacing_y() const {
    return GetField<double>(VT_SPACING_Y, 0.0);
  }
  double spacing_z() const {
    return GetField<double>(VT_SPACING_Z, 0.0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t depth() const {
    return GetField<uint32_t>(VT_DEPTH, 0);
  }
  data image_type() const {
    return static_cast<data>(GetField<uint8_t>(VT_IMAGE_TYPE, 0));
  }
  const void *image() const {
    return GetPointer<const void *>(VT_IMAGE);
  }
  template<typename T> const T *image_as() const;
  const uint8_type *image_as_uint8_type() const {
    return image_type() == data_uint8_type ? static_cast<const uint8_type *>(image()) : nullptr;
  }
  const int16_type *image_as_int16_type() const {
    return image_type() == data_int16_type ? static_cast<const int16_type *>(image()) : nullptr;
  }
  const float_type *image_as_float_type() const {
    return image_type() == data_float_type ? static_cast<const float_type *>(image()) : nullptr;
  }
  const double_type *image_as_double_type() const {
    return image_type() == data_double_type ? static_cast<const double_type *>(image()) : nullptr;
  }
  uint64_t image_size() const {
    return GetField<uint64_t>(VT_IMAGE_SIZE, 0);
  }
  uint16_t num_channels() const {
    return GetField<uint16_t>(VT_NUM_CHANNELS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.Verify(header()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.Verify(origin()) &&
           VerifyOffset(verifier, VT_ENCODING) &&
           verifier.Verify(encoding()) &&
           VerifyField<double>(verifier, VT_SPACING_X) &&
           VerifyField<double>(verifier, VT_SPACING_Y) &&
           VerifyField<double>(verifier, VT_SPACING_Z) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_DEPTH) &&
           VerifyField<uint8_t>(verifier, VT_IMAGE_TYPE) &&
           VerifyOffset(verifier, VT_IMAGE) &&
           Verifydata(verifier, image(), image_type()) &&
           VerifyField<uint64_t>(verifier, VT_IMAGE_SIZE) &&
           VerifyField<uint16_t>(verifier, VT_NUM_CHANNELS) &&
           verifier.EndTable();
  }
};

template<> inline const uint8_type *ImageFbs::image_as<uint8_type>() const {
  return image_as_uint8_type();
}

template<> inline const int16_type *ImageFbs::image_as<int16_type>() const {
  return image_as_int16_type();
}

template<> inline const float_type *ImageFbs::image_as<float_type>() const {
  return image_as_float_type();
}

template<> inline const double_type *ImageFbs::image_as<double_type>() const {
  return image_as_double_type();
}

struct ImageFbsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> header) {
    fbb_.AddOffset(ImageFbs::VT_HEADER, header);
  }
  void add_origin(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> origin) {
    fbb_.AddOffset(ImageFbs::VT_ORIGIN, origin);
  }
  void add_encoding(flatbuffers::Offset<flatbuffers::String> encoding) {
    fbb_.AddOffset(ImageFbs::VT_ENCODING, encoding);
  }
  void add_spacing_x(double spacing_x) {
    fbb_.AddElement<double>(ImageFbs::VT_SPACING_X, spacing_x, 0.0);
  }
  void add_spacing_y(double spacing_y) {
    fbb_.AddElement<double>(ImageFbs::VT_SPACING_Y, spacing_y, 0.0);
  }
  void add_spacing_z(double spacing_z) {
    fbb_.AddElement<double>(ImageFbs::VT_SPACING_Z, spacing_z, 0.0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ImageFbs::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ImageFbs::VT_HEIGHT, height, 0);
  }
  void add_depth(uint32_t depth) {
    fbb_.AddElement<uint32_t>(ImageFbs::VT_DEPTH, depth, 0);
  }
  void add_image_type(data image_type) {
    fbb_.AddElement<uint8_t>(ImageFbs::VT_IMAGE_TYPE, static_cast<uint8_t>(image_type), 0);
  }
  void add_image(flatbuffers::Offset<void> image) {
    fbb_.AddOffset(ImageFbs::VT_IMAGE, image);
  }
  void add_image_size(uint64_t image_size) {
    fbb_.AddElement<uint64_t>(ImageFbs::VT_IMAGE_SIZE, image_size, 0);
  }
  void add_num_channels(uint16_t num_channels) {
    fbb_.AddElement<uint16_t>(ImageFbs::VT_NUM_CHANNELS, num_channels, 0);
  }
  explicit ImageFbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageFbsBuilder &operator=(const ImageFbsBuilder &);
  flatbuffers::Offset<ImageFbs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageFbs>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageFbs> CreateImageFbs(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> header = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> origin = 0,
    flatbuffers::Offset<flatbuffers::String> encoding = 0,
    double spacing_x = 0.0,
    double spacing_y = 0.0,
    double spacing_z = 0.0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t depth = 0,
    data image_type = data_NONE,
    flatbuffers::Offset<void> image = 0,
    uint64_t image_size = 0,
    uint16_t num_channels = 0) {
  ImageFbsBuilder builder_(_fbb);
  builder_.add_image_size(image_size);
  builder_.add_spacing_z(spacing_z);
  builder_.add_spacing_y(spacing_y);
  builder_.add_spacing_x(spacing_x);
  builder_.add_image(image);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_encoding(encoding);
  builder_.add_origin(origin);
  builder_.add_header(header);
  builder_.add_num_channels(num_channels);
  builder_.add_image_type(image_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageFbs> CreateImageFbsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *header = nullptr,
    const std::vector<uint8_t> *origin = nullptr,
    const char *encoding = nullptr,
    double spacing_x = 0.0,
    double spacing_y = 0.0,
    double spacing_z = 0.0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t depth = 0,
    data image_type = data_NONE,
    flatbuffers::Offset<void> image = 0,
    uint64_t image_size = 0,
    uint16_t num_channels = 0) {
  return simple_msgs::CreateImageFbs(
      _fbb,
      header ? _fbb.CreateVector<uint8_t>(*header) : 0,
      origin ? _fbb.CreateVector<uint8_t>(*origin) : 0,
      encoding ? _fbb.CreateString(encoding) : 0,
      spacing_x,
      spacing_y,
      spacing_z,
      width,
      height,
      depth,
      image_type,
      image,
      image_size,
      num_channels);
}

inline bool Verifydata(flatbuffers::Verifier &verifier, const void *obj, data type) {
  switch (type) {
    case data_NONE: {
      return true;
    }
    case data_uint8_type: {
      auto ptr = reinterpret_cast<const uint8_type *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_int16_type: {
      auto ptr = reinterpret_cast<const int16_type *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_float_type: {
      auto ptr = reinterpret_cast<const float_type *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case data_double_type: {
      auto ptr = reinterpret_cast<const double_type *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifydataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!Verifydata(
        verifier,  values->Get(i), types->GetEnum<data>(i))) {
      return false;
    }
  }
  return true;
}

inline const simple_msgs::ImageFbs *GetImageFbs(const void *buf) {
  return flatbuffers::GetRoot<simple_msgs::ImageFbs>(buf);
}

inline const simple_msgs::ImageFbs *GetSizePrefixedImageFbs(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<simple_msgs::ImageFbs>(buf);
}

inline const char *ImageFbsIdentifier() {
  return "IMAG";
}

inline bool ImageFbsBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ImageFbsIdentifier());
}

inline bool VerifyImageFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<simple_msgs::ImageFbs>(ImageFbsIdentifier());
}

inline bool VerifySizePrefixedImageFbsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<simple_msgs::ImageFbs>(ImageFbsIdentifier());
}

inline void FinishImageFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<simple_msgs::ImageFbs> root) {
  fbb.Finish(root, ImageFbsIdentifier());
}

inline void FinishSizePrefixedImageFbsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<simple_msgs::ImageFbs> root) {
  fbb.FinishSizePrefixed(root, ImageFbsIdentifier());
}

}  // namespace simple_msgs

#endif  // FLATBUFFERS_GENERATED_IMAGE_SIMPLE_MSGS_H_
